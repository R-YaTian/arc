
#pragma once
#include <cstdint>
#include <utility>
#include <iterator>

/* This file was automatically generated by arc. */

namespace $NAMESPACE {

    using Result = uint32_t;

    namespace impl {

        constexpr uint32_t ModuleBits = 9;
        constexpr uint32_t DescriptionBits = 13;
        constexpr uint32_t ReservedBits = 10;
        constexpr Result DefaultValue = Result();
        constexpr Result SuccessValue = DefaultValue;

        inline constexpr Result Pack(const uint32_t module, const uint32_t desc) {
            return module | (desc << ModuleBits);
        }

        inline constexpr uint32_t UnpackModule(const Result value) {
            return value & ~(~DefaultValue << ModuleBits);
        }

        inline constexpr uint32_t UnpackDescription(const Result value) {
            return (value >> ModuleBits) & ~(~DefaultValue << DescriptionBits);
        }
        
        inline constexpr uint32_t GetValue(const Result value) {
            return value & ~(~DefaultValue << (ModuleBits + DescriptionBits));
        }

    }

    constexpr Result ResultSuccess = impl::SuccessValue;

    #define $MACRO_RC_MAKE(module, desc) ::$NAMESPACE::impl::Pack(module, desc)

    #define $MACRO_RC_GET_MODULE(rc) ::$NAMESPACE::impl::UnpackModule(rc)

    #define $MACRO_RC_GET_DESC(rc) ::$NAMESPACE::impl::UnpackDescription(rc)

    #define $MACRO_RC_VALUE(rc) ::$NAMESPACE::impl::GetValue(rc)

    #define $MACRO_RC_SUCCEEDED(rc) $MACRO_RC_MATCHES(::$NAMESPACE::ResultSuccess, rc)

    #define $MACRO_RC_FAILED(rc) !$MACRO_RC_SUCCEEDED(rc)

    #define $MACRO_RC_MATCHES(rc1, rc2) ($MACRO_RC_VALUE(rc1) == $MACRO_RC_VALUE(rc2))

    #define $MACRO_RC_SUCCEED return ::$NAMESPACE::ResultSuccess

    #define $MACRO_RC_FAIL(rc) return rc
    
    // ...

    struct ResultRange {
        uint16_t module;
        uint16_t start_desc;
        uint16_t end_desc;

        constexpr ResultRange(const uint16_t module, const uint16_t start_desc, const uint16_t end_desc) : module(module), start_desc(start_desc), end_desc(end_desc) {}

        inline constexpr bool Matches(const Result rc) const {
            return ($MACRO_RC_GET_MODULE(rc) == this->module) && (($MACRO_RC_GET_DESC(rc) >= this->start_desc) && ($MACRO_RC_GET_DESC(rc) <= this->end_desc));
        }
    };

    // ...

$RES_DEFINE

    // ...

$RES_RANGE_DEFINE

    // ...

    constexpr std::pair<Result, std::pair<const char*, const char*>> ResultNameTable[] = {
$RES_TABLE
    };

    constexpr std::pair<ResultRange, std::pair<const char*, const char*>> ResultRangeNameTable[] = {
$RES_RANGE_TABLE
    };

    inline constexpr bool GetResultName(const Result rc, const char *&out_module_name, const char *&out_name) {
        for(size_t i = 0; i < std::size(ResultNameTable); i++) {
            if(ResultNameTable[i].first == rc) {
                out_module_name = ResultNameTable[i].second.first;
                out_name = ResultNameTable[i].second.second;
                return true;
            }
        }

        return false;
    }

    inline constexpr bool GetResultRangeName(const Result rc, const char *&out_module_name, const char *&out_name) {
        for(size_t i = 0; i < std::size(ResultRangeNameTable); i++) {
            if(ResultRangeNameTable[i].first.Matches(rc)) {
                out_module_name = ResultRangeNameTable[i].second.first;
                out_name = ResultRangeNameTable[i].second.second;
                return true;
            }
        }

        return false;
    }

    inline constexpr bool GetResultNameAny(const Result rc, const char *&out_module_name, const char *&out_name) {
        if(GetResultName(rc, out_module_name, out_name)) {
            return true;
        }

        if(GetResultRangeName(rc, out_module_name, out_name)) {
            return true;
        }

        return false;
    }

}